from . import WorkflowEvent, WorkflowFunctions, WorkflowEventListeners, WorkflowEntrypointNodeTransformer, WorkflowAsynchronousNodeTransformer, WorkflowExecutionManager
from copy import deepcopy
from ast import parse, unparse
from textwrap import indent
from asyncio import get_running_loop, current_task, sleep, timeout

class WorkflowManager:
    """
    The `WorkflowManager` serves as the central component responsible for executing
    Python 3 code asynchronously within the workflow subsystem.

    Custom functions can be registered in the `WorkflowManager`, making them accessible
    during workflow execution. Furthermore, the `WorkflowManager` provides hooks into internal
    mechanisms to handle specific events or function executions.

    The provided code is typically synchronous, for example, when generated by a Large
    Language Model (LLM) to reduce model complexity related to asynchronicity. However,
    workflow execution often involves external events that expose its inherently
    asynchronous nature. For this reason, the synchronous or partially synchronous code
    is transformed into an asynchronous representation using Python's coroutines and futures.

    This transformation enables explicit preemption of functions within the workflow.
    The given code is parsed using Pythonâ€™s built-in parser and transformed by the
    `WorkflowEntrypointNodeTransformer` and `WorkflowAsynchronousNodeTransformer` classes.
    The former wraps the original code in an asynchronous entrypoint function, while the
    latter converts synchronous functions and their invocations into asynchronous ones.

    Executing the transformed code produces a single future, whose awaiting resolves the
    workflow and executes the underlying functions using an asynchronous task execution
    runtime.
    """
    def __init__(self):
        self.__functions = WorkflowFunctions()
        self.__event_listeners = WorkflowEventListeners()

    @property
    def functions(self):
        return self.__functions

    @property
    def event_listeners(self):
        return self.__event_listeners

    async def execute(self, source, timeout_in_seconds=None, context=None):
        """
        Executes the given source code, incorporating event handling,
        source transformation, and execution logic.
        """
        if context is None:
            context = {}

        transformed_source = await self.__transform_source(source)

        result = await self.event_listeners.before_execute.trigger(source=transformed_source)
        if result is not None:
            transformed_source = result

        execution_manager = WorkflowExecutionManager(current_task())

        namespace = {
            function.name:self.__create_callable(function, execution_manager, context) for function in self.__functions.functions
        }

        exec(
            transformed_source,
            namespace,
            namespace,
        )

        try:
            async with timeout(timeout_in_seconds):
                await namespace["__workflow__"]()
        finally:
            await self.event_listeners.after_execute.trigger()

        return context

    def __create_callable(self, function, execution_manager, context):
        """
        Creates a wrapper callable that enables hooking into function execution
        or workflow events.
        """

        async def callable(*args, **kwargs):
            event = WorkflowEvent(
                call=True,
            )

            await self.event_listeners.before_execute_function.trigger(
                event=event,
                execution_manager=execution_manager,
                function=function,
                arguments=args,
                keyword_arguments=kwargs,
                context=context,
            )

            if event.call is True:
                return_value = None

                if function.is_asynchronous():
                    if function.has_context():
                        return_value = await function.callable(context, *args, **kwargs)
                    else:
                        return_value = await function.callable(*args, **kwargs)
                else:
                    if function.has_context():
                        return_value = function.callable(context, *args, **kwargs)
                    else:
                        return_value = function.callable(*args, **kwargs)

            await self.event_listeners.after_execute_function.trigger(
                event=event,
                execution_manager=execution_manager,
                function=function,
                arguments=args,
                keyword_arguments=kwargs,
                return_value=return_value,
                context=context,
            )

            return return_value

        return callable

    async def __transform_source(self, source):
        """
        Applies the entry point transformation, followed by the asynchronicity
        transformation, and executes any related events.
        """

        await self.event_listeners.before_execute_source_transformation.trigger(
            source=source,
        )

        ast = WorkflowEntrypointNodeTransformer(
            await self.__transform_ast(parse(source))
        ).visit(
            parse("async def __workflow__():\n  pass"),
        )

        source = unparse(ast)

        await self.event_listeners.after_execute_source_transformation.trigger(
            source=source,
        )

        return source

    async def __transform_ast(self, ast):
        """
        Applies the asynchronicity transformation, and executes any related events.
        """

        await self.event_listeners.before_execute_ast_transformation.trigger(
            ast=ast,
        )

        asynchronous_function_names = set()

        for function in self.__functions.functions:
            asynchronous_function_names.add(function.name)

        ast = WorkflowAsynchronousNodeTransformer(asynchronous_function_names).visit(ast)

        await self.event_listeners.after_execute_ast_transformation.trigger(
            ast=ast,
        )

        return ast
